---
layout: post
title: Recurrent Model of Visual Attention
comments: True
author: nicholas-leonard
---

<!---# Recurrent Model of Visual Attention-->

In this blog post, I want to discuss how we at Element Inc. were able to
implemented the recurrent attention model (RAM) described in [[1]](#rmva.ref). 
Not only were we able to reproduce the paper, but we also made of bunch of
useful and usable (i.e. modular) code available in the process. 
You can reproduce the RAM on the MNIST dataset using this 
[training script](https://github.com/Element-Research/rnn/blob/master/examples/recurrent-visual-attention.lua).
We will use snippets of that script throughout this post.

When we looked at the paper, we decided that it was worth reproducing. 
Let's face it, many of the research papers are difficult or impossible to reproduce
even with help from the original authors [[2]]. 
However, the authors of [[1]] did a great job on making their paper clear, 
concise and relatively easy to reproduce.
All hyper-parameters but two are detailed, which means that hyper-parameter search would be relatively easy.
As for those two, the paper specifies that they were found through random-search.
So we found them through random search.

The paper describes a RAM that can be applied to image classification datasets.
The model is designed in such a way that it has a bandwidth limited sensor of the input image.
So if the input image is of size `28x28` (height x width), the RAM may only be able to 
sense an area of size `8x8` at any given time-step. 
These small sensed areas are refered to as *glimpses*. 

## SpatialGlimpse ##

Actually, the paper's glimpse sensor is little bit more 
complicated than what we described above, but nevertheless simple. 
Keeping in step with the modular spirit of [Torch7]'s [nn] package, we created a 
[SpatialGlimpse](https://github.com/nicholas-leonard/dpnn#nn.SpatialGlimpse) module.

```lua
module = nn.SpatialGlimpse(size, depth, scale)
```

Basically, if you feed it an image, say the classic `3x512x512` Lenna image:

![lenna](images/lenna.png)

And you run this code on it:

```lua
require 'dpnn'
require 'image'

img = image.lena()
loc = torch.Tensor{0,0} -- 0.0 is the center of the image

sg = nn.SpatialGlimpse(64, 3, 2)

output = sg:forward{img, loc}
print(output:size()) --   9 x 64 x 64


-- unroll the glimpse onto its different depths
outputs = torch.chunk(output, 3)
display = image.toDisplayTensor(outputs)
image.save("glimpse-output.png", display)
```

You will end up with the following (unrolled) glimpse :

![glimpse](images/glimpse-output.png)

While the input is a `3x512x512` image (786432 scalars), 
the output is very small : `9x64x64` (36864 scalars), or about 
5% the size of the original image.
Since the glimse here has a `depth=3`, i.e. it uses 3 patches,
Each successive patch is `scale` times the size of the prevous one.
So we end up with a high-resolution patch of a small area, 
and successively lower-resolution (i.e. downscaled) patches of larger areas.
I love how this approximates our own human attention mechanism. 
While we humans can really see the details of what we focus our attention on,
we nevertheless maintain a blurry view of the outskirts.

Although not necessary for reproducing this paper, 
the `SpatialGlimpse` can also be partially backpropagated through.
While the gradient w.r.t. the `img` tensor can be obtained, 
the gradients w.r.t. the `location` (i.e. the `x,y` coordinates of the glimpse) will be zero. 
This is because the glimpse operation cannot be differentiated w.r.t. the `location`.
Which brings us to the main difficulty of attention models : 
how can we teach the network to glimpse at the right `locations`?

## REINFORCE algorithm ##

Some attention models use a fully differentiable attention mechanism, 
like the recent DRAW paper [[3]](#rmva.ref). 
But the RAM model uses a non-differenciable attention mechanism.
Specifically, it uses a the REINFORCE algorithm [[4]]. 
This algorithm allows one to train stochastic units through reinforcement learning.

The REINFORCE algorithm is very powerful as it can be 
used to optimize stochastic units (conditioned on an input),
such that they minimize an objective function.
Unlike backpropagation [[5]], this objective function doesn't need
to be differentiable.

The RAM model uses the REINFORCE algorithm to train the `locator` network :

```lua
-- actions (locator)
locator = nn.Sequential()
locator:add(nn.Linear(opt.hiddenSize, 2))
locator:add(nn.HardTanh()) -- bounds mean between -1 and 1
locator:add(nn.ReinforceNormal(2*opt.locatorStd)) -- sample from normal, uses REINFORCE learning rule
locator:add(nn.HardTanh()) -- bounds sample between -1 and 1
locator:add(nn.MulConstant(opt.unitPixels/ds:imageSize("h")))
```

The input is the previous recurrent hidden state `h[t-1]`. 
During training, the output is sampled from a normal 
distribution with fixed standard deviation.
The mean is conditioned on `h[t-1]` through an affine transform (`Linear`).
During evaluation, instead of sampling, the output is taken to be the input, i.e. the mean.

The [ReinforceNormal](https://github.com/nicholas-leonard/dpnn#nn.ReinforceNormal) module 
implements the REINFORCE algorithm for the normal distribution.
Unlike most `Modules`, `ReinforceNormal` ignores the `gradOutput` when `backward` is called.
This is because the units it embodies are in fact stochastic.
So then how does it generate `gradInputs` when the `backward` is called?
It uses the REINFORCE algorithm, which requires that a reward function be defined.
The reward uses by the paper is very simple, and yet not differentiable (eq. 1) :
```
R = I(y=t)
```
where `R` is the raw reward, `I(x)` is `1` when `x` is true and `0` otherwise (indicator function), 
`y` is the predicted class, `t` is the target class. 
Or in Lua :
```lua
R = y==t and 1 or 0
```

The REINFORCE algorithm requires that we differentiate the 
probability density or mass function (PDF/PMF) of the distribution
w.r.t. the parameters. So given the following variables :

  * `f` : normal probability density function
  * `x` : the sampled values (i.e. `ReinforceNormal.output`)
  * `u` : mean (`input` to `ReinforceNormal`)
  * `s` : standard deviation (`ReinforceNormal.stdev`)

the derivative of log normal w.r.t. mean `u` is :
```
d ln(f(x,u))   (x - u)
------------ = -------
     d u         s^2
```

So where does `d ln(f(x,u,s) / d u` fit in with the reward? 
Well, in order to obtain a pseudo-gradient of the reward `R` w.r.t.
to input `u`, you apply the following equation (eq. 2, i.e. the REINFORCE algorithm):
```
d R                 d ln(f(x,u)) 
--- = a * (R - b) * --------------
d u                      d u 
```
where 
 
  * `a` (alpha) is just a scaling factor like the learning rate ; and
  * `b` is a baseline reward used to reduce the variance of the gradient. 
  * `f` is the PMF/PDF
  * `u` is the parameter w.r.t. which you want to get a gradient
  * `x` is the sampled value.
  
In the paper, they take `b` to be the expected reward `E[R]`, which 
they approximate by making `b` a parameter of the model 
that tries to match `R` using backpropagation through the mean 
squared error between `b` and `R`. The beauty of doing this, instead of 
say making `b` a moving average of `R`, is that the baseline reward `b`
learns at the same rate as the rest of the model. 

We decided to implement the `reward = a * (R - b)` part of eq. 2
within the [VRClassReward](https://github.com/nicholas-leonard/dpnn/blob/master/README.md#nn.VRClassReward) criterion,
which also implements the paper's reward function for classification eq. 1:

```lua
vcr = nn.VRClassReward(module [, scale, criterion])
```

The nn package was primarily built for backpropagation, so we had to find a hacky way of
broadcasting the `reward` to the different 
[Reinforce](https://github.com/nicholas-leonard/dpnn/blob/master/README.md#nn.Reinforce) modules.
We did this by having the criterion take the `module` as argument,
and adding the [Module:reinforce(reward)](https://github.com/nicholas-leonard/dpnn/blob/master/README.md#nn.Module.reinforce)
method. The latter allows the `Reinforce` modules (like `ReinforceNormal`) to 
hold on to the broadcasted `reward` for later. Later being when `backward` is called 
and the `Reinforce` module(s) computes the `gradInput` 
(i.e. `d R / d U`) using the REINFORCE algorithm (eq. 2).
And then `nn` is happy, because with the `gradInput`, it can continue 
the backpropagation from the `Reinforce` module to its predecessors.

If you can differentiate the PMF/PDF w.r.t. to its parameters,
then you can use the REINFORCE algorithm on it. We have already implemented 
modules for the categorical and bernoulli distributions :
   
   * [ReinforceCategorical](https://github.com/nicholas-leonard/dpnn/blob/master/README.md#nn.ReinforceCategorical)
   * [ReinforceBernoulli](https://github.com/nicholas-leonard/dpnn/blob/master/README.md#nn.ReinforceBernoulli)


<a name='rmva.ref'></a>
## References

1. *Volodymyr Mnih, Nicolas Heess, Alex Graves, Koray Kavukcuoglu*, Recurrent Models of Visual Attention, [[NIPS 2014]](http://papers.nips.cc/paper/5542-recurrent-models-of-visual-attention)
2. **, (http://www.sciencemag.org/content/349/6251/aac4716)
3. DRAW
4. REINFORCE
5. Backprop
3. *Yoshua Bengio, Nicholas Leonard, Aaron Courville*. Estimating or Propagating Gradients Through Stochastic Neurons for Conditional Computation [[arxiv]](http://arxiv.org/abs/1308.3432)
